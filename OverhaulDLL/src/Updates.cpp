/*
    DARK SOULS OVERHAUL

    Contributors to this file:
        Sean Pesce  -  C++
*/

#include "Updates.h"
#include "FileUtil.h"

#include <curl/curl.h>

#include <cctype>
#include <regex>
#include <set>
#include <map>
#include <sstream>

#include "SP_SysUtils.hpp"


namespace Updates {

// Month abbreviations generated by MSVC __DATE__ preprocessor macro
const std::set<std::string> _months{ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
const std::map<std::string, unsigned int> _month_map{  { "Jan", 1 }, { "Feb", 2 }, { "Mar", 3 }, { "Apr", 4 }, { "May", 5 }, { "Jun", 6 }, { "Jul", 7 }, { "Aug", 8 }, { "Sep", 9 }, { "Oct", 10 }, { "Nov", 11 }, { "Dec", 12 }  };


// Overhaul message of the day (MotD)
std::string _message_of_the_day;

// Latest Overhaul DLL build version
std::string _latest;

// Latest download link
std::string _download;


const std::string _sources[DS1_OVERHAUL_UPDATE_SOURCE_COUNT_] =
                          {
                              "https://raw.githubusercontent.com/metal-crow/Dark-Souls-1-Overhaul/PtDE/OverhaulDLL/rsrc/Updates/",
                              "https://bitbucket.org/SeanPesce/darksoulsoverhaulupdates/raw/master/PtDE/",
                              "https://gitlab.com/SeanPesce/DarkSoulsOverhaulUpdates/raw/master/PtDE/"
                          };

// Flags to skip checking remote data sources
bool skip_source[DS1_OVERHAUL_UPDATE_SOURCE_COUNT_] = { false, false, false };

bool keep_temp_files = false;

bool _motd_initialized         = false;
bool _latest_initialized       = false;
bool _download_url_initialized = false;


// Returns string containing the Overhaul message of the day (MotD)
std::string motd()
{
    if (!Updates::_motd_initialized)
    {
        check_motd();
        Updates::_motd_initialized = true;
    }
    return _message_of_the_day;
}


// Returns string containing latest Overhaul DLL build version
std::string latest()
{
    if (!Updates::_latest_initialized)
    {
        check_latest();
        Updates::_latest_initialized = true;
    }
    return _latest;
}


// Returns URL to latest Overhaul DLL download
std::string download_url()
{
    if (!Updates::_download_url_initialized)
    {
        check_download_url();
        Updates::_download_url_initialized = true;
    }
    return _download;
}


bool valid_version_str(const std::string& s)
{
    if (s.length() >= std::string(Updates::VERSION).length())
    {
        // Date
        std::string month = s.substr(0, 3);
        if (std::find(Updates::_months.begin(), Updates::_months.end(), month) != Updates::_months.end())
        {
            if ((std::isdigit(s[4]) || s[4] == ' ') && std::isdigit(s[5]) && std::isdigit(s[7]) && std::isdigit(s[8]) && std::isdigit(s[9]) && std::isdigit(s[10]))
            {
                // Time
                if (std::isdigit(s[13]) && std::isdigit(s[14]) && std::isdigit(s[16]) && std::isdigit(s[17]) && std::isdigit(s[19]) && std::isdigit(s[20]))
                {
                    return true;
                }
            }
        }
    }
    return false;
}


// Checks online for a new Overhaul MotD.
// Data is be obtained from a remote source using CURL (default source is the Overhaul repository)
void check_motd()
{
    static constexpr const char* tmp_file    = "DS_OVERHAUL_MOTD";
    static constexpr const char* remote_file = "MOTD";
    for (int i = 0; i < DS1_OVERHAUL_UPDATE_SOURCE_COUNT_; i++)
    {
        print_console(std::string("Attempting to obtain message of the day") + (i ? " (Host #" + std::to_string(i+1) + ")..." : "..."));

        if (Updates::skip_source[i])
        {
            print_console("    Skipped");
            continue;
        }

        if (fetch_data(_sources[i]+remote_file, tmp_file) == SP_NO_ERROR)
        {
            size_t length = FileUtil::file_size(tmp_file);
            char* motd = (char*)FileUtil::read_from_offset(tmp_file, 0, length, NULL, true);
            if (motd)
            {
                motd[length-1] = '\0';
                if (length > 10000)
                {
                    motd[10000] = '\0';
                }

                _message_of_the_day = motd;
                //if (!_message_of_the_day.empty())
                //{
                //    print_console("\nOVERHAUL MESSAGE OF THE DAY:\n" + _message_of_the_day);
                //    print_console("");
                //}
                //else
                //{
                //    // MotD was empty
                //    print_console("    No message.");
                //}
                //CoTaskMemFree((void*)motd);
            }
            else
            {
                print_console("    ERROR: Remote fetch succeeded, but failed to read local data");
            }
            break;
        }
    }
    if (!Updates::keep_temp_files) std::remove(tmp_file);
}


// Checks online for the latest Overhaul version string
void check_latest()
{
    static constexpr const char* tmp_file    = "DS_OVERHAUL_VERSION";
    static constexpr const char* remote_file = "VERSION";
    for (int i = 0; i < DS1_OVERHAUL_UPDATE_SOURCE_COUNT_; i++)
    {
        print_console(std::string("Attempting to obtain latest version info") + (i ? " (Host #" + std::to_string(i + 1) + ")..." : "..."));

        if (Updates::skip_source[i])
        {
            print_console("    Skipped");
            continue;
        }

        if (fetch_data(_sources[i] + remote_file, tmp_file) == SP_NO_ERROR)
        {
            size_t length = FileUtil::file_size(tmp_file);
            char* ver = (char*)FileUtil::read_from_offset(tmp_file, 0, length, NULL, true);
            if (ver)
            {
                ver[length-1] = '\0';
                if (Updates::valid_version_str(ver))
                {
                    if (length > 50)
                    {
                        ver[50] = '\0';
                    }

                    _latest = ver;

                    // Clean trailing garbage data
                    size_t pos = _latest.find_first_of("\r\n");
                    if (pos != std::string::npos)
                    {
                        _latest = _latest.substr(0, pos);
                    }

                    //if (!_latest.empty())
                    //{
                    //    if (_latest == std::string(Updates::VERSION))
                    //    {
                    //        print_console("    No new updates.");
                    //    }
                    //    else
                    //    {
                    //        print_console("\n    POSSIBLE UPDATE AVAILABLE:\n    Local build:  " + std::string(Updates::VERSION) + "\n    Remote build: " + _latest
                    //                      + "\n\n    " + (Updates::download_url().empty() ? "Download URL unknown; try here:\n    " DS1_OVERHAUL_DEFAULT_DOWNLOAD_URL_
                    //                                      : ("Download the latest version here:\n    " + Updates::download_url())));
                    //        print_console("");
                    //    }
                    //}
                    //else
                    //{
                    //    // Version string was empty
                    //    print_console("    No version info.");
                    //}
                }
                
                CoTaskMemFree((void*)ver);
            }
            else
            {
                print_console("    ERROR: Remote fetch succeeded, but failed to read local data");
            }
            break;
        }
    }
    if (!Updates::keep_temp_files) std::remove(tmp_file);
}


// Checks online for the latest Overhaul download URL
void check_download_url()
{
    static constexpr const char* tmp_file    = "DS_OVERHAUL_DOWNLOAD";
    static constexpr const char* remote_file = "DOWNLOAD";
    for (int i = 0; i < DS1_OVERHAUL_UPDATE_SOURCE_COUNT_; i++)
    {
        if (Updates::skip_source[i])
        {
            continue;
        }

        if (fetch_data(_sources[i] + remote_file, tmp_file, true) == SP_NO_ERROR)
        {
            size_t length = FileUtil::file_size(tmp_file);
            char* url = (char*)FileUtil::read_from_offset(tmp_file, 0, length, NULL, true);

            if (url)
            {
                url[length-1] = '\0';
                if (length > 1024)
                {
                    url[1024] = '\0';
                }
                std::string url_str(url);
                
                // Clean trailing garbage data
                size_t pos = url_str.find_first_of(" \r\n");
                if (pos != std::string::npos)
                {
                    url_str = url_str.substr(0, pos);
                }

                // Check for valid URL
                if (std::regex_match(url_str, std::regex("^(?:http(s)?:\\/\\/)?[\\w.-]+(?:\\.[\\w\\.-]+)+[\\w\\-\\._~:/?#[\\]@!\\$&'\\(\\)\\*\\+,;=.]+$"))) // RegEx source: https://www.regextester.com/94502
                {
                    _download = (char*)url_str.c_str();
                }
                CoTaskMemFree((void*)url);
            }
            break;
        }
    }
    if (!Updates::keep_temp_files) std::remove(tmp_file);
}


// Retrieves data from the specified remote URL and saves it to a local file
long fetch_data(const std::string& source, const std::string& output_file, bool silent)
{
    static constexpr const char *error_curl = "    CURL ERROR: ";
    static constexpr const char *error_opening_file_write = "    WRITE ERROR: Failed to create or open ";
    static constexpr const char *error_closing_file[2] = { "    WRITE ERROR: Problem when attempting to close ", " after writing data" };
    static constexpr const char *error_http = "    HTTP ERROR: ";

    int error_code = SP_NO_ERROR;

    char error_msg_buffer[CURL_ERROR_SIZE+1];
    error_msg_buffer[0] = '\0';
    error_msg_buffer[CURL_ERROR_SIZE] = '\0';

    // Initialize file handle for the file that the web data will be written to
    FILE *out_file_handle;
    if (fopen_s(&out_file_handle, output_file.c_str(), "w+") || out_file_handle == NULL)
    {
        error_code = ERROR_WRITE_FAULT; // Unable to open file for writing
        if (!silent) print_console(std::string(error_opening_file_write) + output_file.c_str());
        return error_code;
    }
    
    // Initialize CURL
    CURL* request;
    CURLcode result;
    request = curl_easy_init();
    curl_easy_setopt(request, CURLOPT_URL, source.c_str());
    curl_easy_setopt(request, CURLOPT_WRITEDATA, (void*)out_file_handle);
    curl_easy_setopt(request, CURLOPT_ERRORBUFFER, error_msg_buffer);
    curl_easy_setopt(request, CURLOPT_USERAGENT, "DS-PtDE-Overhaul/1.0");

    // Attempt to fetch data from the web
    result = curl_easy_perform(request);

    if (result != CURLE_OK)
    {
        // Encountered network error
        error_code = ERROR_UNEXP_NET_ERR;
        if (std::string(error_msg_buffer).length() > 0)
        {
            if (!silent) print_console(std::string(error_curl) + error_msg_buffer);
        }
        else if (std::string(curl_easy_strerror(result)).length() > 0)
        {
            if (!silent) print_console(std::string(error_curl) + curl_easy_strerror(result));
        }
    }
    curl_easy_cleanup(request); // CURL cleanup

    // Close output file handle
    if (fclose(out_file_handle))
    {
        // Error closing file handle
        if (!silent) print_console(std::string(error_closing_file[0]) + output_file.c_str() + error_closing_file[1]);
        //if (error_code == SP_NO_ERROR)
        //    error_code = ERROR_WRITE_FAULT;
    }

    // Check for CURL error
    if (error_code != SP_NO_ERROR)
    {
        if (!Updates::keep_temp_files) std::remove(output_file.c_str());
        return error_code;
    }

    // Check for response code error
    long response_code = 200L; // Initialize as code 200 (OK)
    curl_easy_getinfo(request, CURLINFO_RESPONSE_CODE, &response_code);

    if (response_code >= 400)
    {
        if (!silent) print_console(error_http + std::to_string(response_code));
        if (!Updates::keep_temp_files) std::remove(output_file.c_str());
        error_code = ERROR_BAD_NET_RESP;
    }

    return error_code;
}



unsigned int ver_month(const std::string& v)
{
    auto it = Updates::_month_map.find(v.substr(0, 3));
    if (it != _month_map.end())
    {
        return it->second;
    }
    return 0;
}


// Returns positive if remote is newer, 0 if equal, or negative if remote is older
int compare_versions()
{
    std::string v(Updates::VERSION);
    unsigned int remote_month = Updates::ver_month(Updates::latest());
    unsigned int local_month  = Updates::ver_month(v);
    // Year
    std::string remote = Updates::latest().substr(7, 4);
    std::string local  = v.substr(7, 4);
    // Month
    remote += (remote_month >= 10) ? std::to_string(remote_month) : "0" + std::to_string(remote_month);
    local  += (local_month  >= 10) ? std::to_string(local_month)  : "0" + std::to_string(local_month);
    // Day
    remote += (Updates::latest()[4] == ' ') ? '0' : Updates::latest()[4];
    local  += (v[4] == ' ') ? '0' : v[4];
    remote += Updates::latest()[5];
    local  += v[5];
    // Hour
    remote += Updates::latest().substr(13, 2);
    local  += v.substr(13, 2);
    // Minute
    remote += Updates::latest().substr(16, 2);
    local  += v.substr(16, 2);
    // Second
    remote += Updates::latest().substr(19, 2);
    local  += v.substr(19, 2);
    return strcmp(remote.c_str(), local.c_str()); // Pos if remote is newer, 0 if equal, neg if remote is older
}


//unsigned int ver_day(const std::string& v)
//{
//    unsigned int d = 0;
//    switch (v[4])
//    {
//        case '3':
//            d = 30;
//            break;
//        case '2':
//            d = 20;
//            break;
//        case '1':
//            d = 10;
//            break;
//        case ' ':
//            break;
//        default:
//            return 0;
//    }
//    d += (v[5] - '0');
//    return (d <= 31) ? d : 0;
//}
//
//unsigned int ver_year(const std::string& v)
//{
//    std::string year = v.substr(7, 4);
//    unsigned int y = (year[0] - '0') * 1000;
//    y += (year[1] - '0') * 100;
//    y += (year[2] - '0') * 10;
//    return y + (year[3] - '0');
//}
//
//unsigned int ver_hour(const std::string& v)
//{
//    unsigned int h = (v[13] - '0') * 10;
//    return h + (v[14] - '0');
//}
//
//unsigned int ver_minute(const std::string& v)
//{
//    unsigned int m = (v[16] - '0') * 10;
//    return m + (v[17] - '0');
//}
//
//unsigned int ver_second(const std::string& v)
//{
//    unsigned int s = (v[19] - '0') * 10;
//    return s + (v[20] - '0');
//}
//
//
//bool compare_versions()
//{
//    std::string local(Updates::VERSION);
//    if (Updates::latest().length() >= local.length())
//    {
//        unsigned int latest_val = Updates::ver_year(Updates::latest());
//        unsigned int local_val  = Updates::ver_year(local);
//        // Year
//        if (latest_val > local_val)
//        {
//            return true;
//        }
//        else if (latest_val == local_val)
//        {
//            // Month
//            latest_val = Updates::ver_month(Updates::latest());
//            local_val  = Updates::ver_month(local);
//            if (latest_val > local_val)
//            {
//                return true;
//            }
//            else if (latest_val == local_val)
//            {
//                // Day
//                latest_val = Updates::ver_day(Updates::latest());
//                local_val  = Updates::ver_day(local);
//                if (latest_val > local_val)
//                {
//                    return true;
//                }
//                else if (latest_val == local_val)
//                {
//                    // Hour
//                    latest_val = Updates::ver_hour(Updates::latest());
//                    local_val  = Updates::ver_hour(local);
//                    if (latest_val > local_val)
//                    {
//                        return true;
//                    }
//                    else if (latest_val == local_val)
//                    {
//                        // Minute
//                        latest_val = Updates::ver_minute(Updates::latest());
//                        local_val  = Updates::ver_minute(local);
//                        if (latest_val > local_val)
//                        {
//                            return true;
//                        }
//                        else if (latest_val == local_val)
//                        {
//                            // Second
//                            latest_val = Updates::ver_second(Updates::latest());
//                            local_val  = Updates::ver_second(local);
//                            if (latest_val > local_val)
//                            {
//                                return true;
//                            }
//                        }
//                    }
//                }
//            }
//        }
//    }
//    return false;
//}



} // namespace Updates
